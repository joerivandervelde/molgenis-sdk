
<molgenis name="org.molgenis.omx">
	<module name="core" label="Core module">
		<description>
			Absolute minimal OMX v3 model without decorators, labels,
			hidden, or other (model-technically unneeded) modifiers for now.
			Golden rule: this XML is completely stand-alone useable!
		</description>

		<entity name="AutoId" abstract="true">
			<description>Database auto-incremented primary key for every record.</description>
			<field name="Id" type="autoid" description="Auto-incremented primary key." />
		</entity>

		<entity name="Identifiable" implements="AutoId" abstract="true" xref_label="Identifier,Name"
			 >
			 <!-- xref_label_todo="${Identifier}[#if Name?exists] (${Name})[/#if]" -->
			<description>
				All data types that needs some form of human recognizability should extend from Identifiable. This adds an 'Identifier' field which is human- and computer readable, and a 'Name' field which acts like a pretty human readable label.
			</description>
			<field name="Identifier" type="string" description="'Acts both as a machine- and human readable secondary key. This string value conforms to a few naming rules and is safe to use in different enviroments (operating systems, programming languages, etc). Typical names are 'HGVST007625' or 'INDV00034'. When not provided, it is created automatically. Forexample 'Marker_00000001' or 'Study_00000345'."/>
			<field name="Name" nillable="true" type="string" description="'Name' acts like a humanreadable 'label' field. It is not unique and can contain 'unsafe' characters." />
			<unique fields="Identifier" description="The identifier is globally unique so it can be used as a secondary key, and 'external identifier'."/>
			<unique fields="Name,Identifier" description="We add an extra secondary key including 'Name' so labels can be conveniently created."/>
		</entity>
		
		<entity name="SystemClass" system="true" implements="AutoId" xref_label="EntityClassName">
			<description>
				Referenceable catalog of this applications' menus, forms and plugins. The contents of this table is generated using and GUI items, and should under no circumstance be modified at runtime by anyone.
			</description>
			<field name="EntityName" nillable="false" description="Name of the entity, e.g. 'AdminMenu' or 'ProtocolViewerPlugin'." />
			<field name="EntityType" nillable="false" description="Type of the entity: 'FORM', 'PLUGIN' or 'MENU'." />
			<field name="EntityClassName" nillable="false" unique="true" description="Unique full class name of the entity, e.g. 'app.ui.ProtocolViewerPlugin'." />
			<unique fields="EntityName,EntityType" description="Name is unique within type, so e.g. there can be both a form 'ProtocolViewer' and a plugin 'ProtocolViewer'."/>
		</entity>
		
		<entity name="EntityClass" extends="SystemClass">
			<description>
				Referenceable catalog of generated database entity class names. The content of EntityClass is automatically filled by 'FillMeta', and should under no circumstance be modified at runtime by anyone.
			</description>
		</entity>
		
		<entity name="ValueClass" extends="EntityClass">
			<description>
				All classes that implement Value directly. Useful for selecting ValueType in Feature. Any classes that implement Target (which is a special type of Value) are ignored here. ValueClass cannot be customized by the user at runtime.
			</description>
		</entity>
		
		<entity name="TargetClass" extends="EntityClass">
			<description>
				All classes that implement Target. Useful for selecting ScopeClass in Feature.
				The content of TargetClass is automatically filled by 'FillMeta', and should under no circumstance be modified at runtime by anyone. The content of TargetClass is automatically filled by 'FillMeta', and should under no circumstance be modified at runtime by anyone. Runtime extension happens via CustomClass.
			</description>
		</entity>
		
		<entity name="CustomClass" extends="TargetClass">
			<description>
				User defined runtime extentions for the catalog of generated (predefined) entity names. Acts as a new class, but with no additional properties relative to the class it is extending.
		<!-- 
			Concepts are abstract objects that mediate between thought, language, and referents.
			In Observ-OMX, concepts can be defined on any abstraction level, including the point where abstraction reaches a minimum and actual physical objects are denoted.
			Concepts can be specified via subclasses, for example 'Marker' as a direct subclass of Concept, 'Target' to denote physical objects in general, or 'Individual' as a subclass of Target.
			When not subclassed, Concept usually depicts a characteristic or quality belonging to a concept or target.
			Because Concept is a superclass of Target, the latter can be used interchangeably via references on the level of Concept.
			This enables e.g. applying a Concept to a Concept to add 'runtime attributes' or create Target versus Target data in the case of correlation matrices.
			General examples of Concepts: "Patient", "Height", "Marker pkP1050", "Panel", "Heart rate", "Sample".
			Examples of concepts on different abstraction levels: "Gene", "Gene expression", "Gene HOXD9", or "Blood pressure", "Systolic blood pressure".
			 -->
			</description>
			<field name="ExtendsClass" type="xref" xref_field="EntityClass.Id" nillable="true" description="The parent of this CustomClass from which fields are inherited. If this is left empty, there will be no known columns (fields) associated with this Class, and any data stored will go in the flexible (runtime defined) columns. This field can be used to build a hierarchy of classes, where a CustomClass inherits all columns (predefined or flexible) from all preceding CustomClasses, th root being either an EntityClass or CustomClass." />
			<field name="Description" type="text" nillable="true" description="Rudimentary meta data about this CustomClass. Use of ontology terms references to establish unambigious descriptions is recommended." />
			<field name="OntologySource" type="mref" xref_entity="OntologySource" nillable="true" description="Ontological annotation for this CustomClass. Refers to any kind of third-party identifier that helps to establish an unambiguous identification."/>
		</entity>
		
		<entity name="Value" implements="AutoId">
			<description>
				Either 1) the outcome of an Observation on a particular DataItem, or 2) data that belongs to a flexible column attached to an EntityClass (or CustomClass). When used for 1): Values are referenced by ObservedValue, which belong to an Observation, which is in essence a row in a DataSet. The ObservedValue also references the DataItem to which this Value belongs, which therefore acts like a column. When used for 2): Referenced by FlexColValue, which attached data to the flexible column structure via references to FlexCol and Target.[Development note: this class should behave like an abstract class, but it cannot be defined as such, because cross-references are currently not possible to abstract classes. We need to enable this, provided there is at least one implementation of the class, so the references happen to the implementing clas(ses).]
			</description>
		</entity>

		<entity name="Target" extends="Value" implements="Identifiable" xref_label="Identifier">
			<description>
			
				Superclass of any object that can be measured or act as a measurement itself. Target is the main extension point of OMX3.
				
				It extends value so any instance can be used in lookup lists in DataSets (using ObservedValue) or as data for flexible columns (using FlexColValue).
				
				What happens in practice is: A datamodel extension of OMX3, for example 'XGAP', adds an entity called Gene, which extends Target. The Gene entity has all kinds of fields such as 'Chromosome', 'BpStartPosition', and so on. In the user interface, there are generated forms for Gene, and it acts as any regular entity genered by MOLGENIS. However, via the Target extension via OMX3, it is possible to: 1) Use any instance of Gene as a lookup Value in either data sets or flexible columns, because Target extends Value. 2) Using the CustomClass field in Target, any instance of Gene can be subclassed at runtime. For exaple, the class Gene can be subclassed to 'EnsemblGene', adding a new field 'EnsemblId' via flexible columns. Now, these EnsemblGenes are like regular Genes, except they have an extra column. [Development note: this requires a bit of business logic to check if the CustomClass is actually a subclass of the implementing class of the Target.]
				
				Targets are concrete objects, typically a physical object or a collection thereof, but can also be an instance of a data type such as 'DataSet' or 'Protocol'. They are typically subjects for observation of particular features. Features that refer to a Target as their MeasuredConcept gain an immediate constraint: the measured value MUST be an XrefValue, and the value MUST be a Target or subclass thereof. Furthermore, a flag can be set on DataSet to check if the referred Targets (or a combination of multiple Targets) are unique.
				Example: 'Protocol' extends 'Target' because every instance of 'Protocol' can be referred to in a column of data. But to explain that you're measuring 'the concept of a protocol', you should create a Concept named 'Protocol' (with possible ontological references) to explain what you mean, and refer to this Concept via Feature. 

				Add the soft type to instances of genes, individuals etc...
				By default the soft type is the same as the original type (a new Gene is created as TypeOf 'Gene'), but this can be changed to custom concepts that extend the original type.
				TODO: decorator that only allows user to select softtypes that extend the original type!!
				
				SHOULD BEHAVE LIKE ABSTRACT CLASS
				
			</description>
			<field name="CustomClass" type="xref" xref_field="CustomClass.Id" nillable="true" description="(Optional) Specialization of this data type, e.g. 'Gene' subtyped into 'EnsemblGene'.)"  />
		</entity>
		
		<entity name="FlexCol" implements="Identifiable">
			<description>
				Add a column to a type of Target at runtime. EntityClass is the datatype (class) you wish to extend. This can be a predefined or a custom class. The definition of the column is given via Feature.
			</description>
			<field name="TargetClass" type="xref" xref_entity="TargetClass" nillable="false" description="" />
			<field name="Feature" type="xref" xref_entity="Feature" nillable="false" description="" />
			<unique fields="TargetClass,Feature" description="A feature can only be one flexible column"/>
		</entity>
		
		<entity name="FlexColValue" implements="Identifiable">
			<description>
				A single value for a FlexCol. The row/column placement of this value is defined via FlexCol and Target, the value given is referenced via Value. There can be only FlexColValue for a FlexCol/Target combination.
			</description>
			<field name="FlexCol" type="xref" xref_entity="FlexCol" nillable="false" description="" />
			<field name="Target" type="xref" xref_entity="Target" nillable="false" description="" />
			<field name="Value" type="xref" xref_entity="Value" nillable="false" description="" />
			<unique fields="FlexCol,Target" description="A value can only be measured once per target per flexible column"/>
		</entity>

		<entity name="Feature" implements="Identifiable" xref_label="Name">
			<description>
				The characterization of the role or the particular procedure of involvement for a Concept in an ObservationSet. The role 'target' replaces the old target XREF in value/ObservationSet and can consist of multiple targets that together form one (possibly unique) target.
				Move HasUniqueValues / AllowMultipleValuesInCell to DataItem ?
			</description>
			<field name="Unit" type="xref" xref_entity="OntologyTerm" nillable="true" description="(Optional) Reference to the well-defined measurement unit used to observe this feature (if feature is that concrete). E.g. mmHg. Does not make any assumptions on the data type, e.g. integer or string." />
			<field name="Definition" type="xref" xref_entity="OntologyTerm" description="The concept that is being measured in a specific way." nillable="true" />
			<field name="ValueType" type="xref" xref_entity="ValueClass" nillable="false" description="The class that holds the values, e.g. DecimalValue, XrefValue or StringValue." />	
			<field name="ScopeClass" type="xref" xref_entity="TargetClass" nillable="true" description="Used to constrain DataItem scope within a Feature. For XrefValue and MrefValue, the reference to a type of Target will result in a lookup list of instances of that type. For example, it could refer to Individual, resulting in a lookup of Individuals (including subclasses), or Patient (extends Individual), resulting in a lookup of only Patients. This field is not needed when there is only one DataItem for a Feature, and the ValueType is not XREF or MREF."/>
			<field name="PermittedValues" type="mref" xref_entity="Value" nillable="true" description="Refer to specific value instances or filters (that include 0..N values implicitly) as allowed values for this Feature"/>
			<field name="AllowMultipleValuesInCell" type="bool" default="false" nillable="false" description="Multiple values in a single cell" />
			<field name="HasUniqueValues" type="bool" default="false" nillable="false" description="If set to true, all values are unique within this this DataItem. Use this when you want to make sure a 'row identifier' is respected, e.g. a list of microarray probes named 'AGI00001', 'AGI00002' are not duplicated." />
			<field name="Temporal" type="boolean" nillable="true" description="Whether this feature is time dependent and can have different values when measured on different times (e.g. weight, temporal=true) or generally only measured once (e.g. birth date, temporal=false) It is advisable to move temporal features to become dynamic attributes of Targets (or Concepts)" />
		</entity>

		<entity name="Filter" extends="Value" implements="AutoId" xref_label="Expression">
			<description>
				A special kind of Value which is often a range of values, or a dynamic query. The interpretation of these filters is left to the application. They can be used via PermittedValues in Feature, to allow for e.g. a range of integers to be accepted as values for an incoming dataset. This prevents a scenario where all allowed integer values would have to be entered in in database first, then each referred to as a PermittedValue, and then validate against the complete range when importing a dataset. That would be inefficient on many levels.
			</description>
			<field name="Expression" unique="true" description="Some constraint expression like '30..300', '>15', 'heart*', 'a-zA-Z0-9', 'q(id_EQUALS_23)' or 'q(label_LIKE_yes)'"/>
			<field name="AppliedTo" type="xref" xref_entity="EntityClass" nillable="false"/>
		</entity>
		
		<entity name="Protocol" extends="Target">
			<description>
				The Protocol class defines parameterizable descriptions of (analysis)methods. Examples of protocols are: Questionaires, SOPs, assay platforms, statistical analyses, etc. Each protocol has a unique identifier. Protocol has an association to OntologyTerm to represent the type of protocol.
			</description>
			<field name="Features" type="mref" nillable="true" xref_entity="Feature"
				description="Methods of observing a feature or describing the role of a target in this protocol. This includes all Features in this protocol, and contains all Features in all SubProtocols, if any." />
			<field name="ProtocolType" nillable="true" type="xref"
				xref_entity="OntologyTerm" description="Classification of protocol. TODO: Examples?" />
			<field name="SubProtocols" type="mref" xref_entity="SubProtocol"
				nillable="true" description="Subprotocols of this protocol, or subprotocol." />
		</entity>
		
		<entity name="SubProtocol" extends="Protocol">
			<description>
				A subprotocol will not be shown if asking for 'main' protocols (e.g. in the protocol browser). Subunit or component of a larger protocol. Can be part of multiple protocols, and can contain even smaller parts (subprotocols) itself. All Features that are part of SubProtocols are added to the Features of the 'source' Protocol.
			</description>
		</entity>
		
		<entity name="DataSource" implements="Identifiable">
			<description>
				Should be filled with some defaults, e.g. "Database"
			</description>
			<field name="todo"/>
		</entity>

		<entity name="DataSet" extends="Target">
			<description>
				A data set is a collection of data, usually presented in tabular form. Each column represents a particular variable. Each row corresponds to a given member of the data set in question. It lists values for each of the variables, such as height and weight of an object. The variables included correspond to the ones in the protocol that this data set belongs to. Any data set and can therefore be thought of as an instance of the protocol it belongs to, like rows in a database are instances of their table definition.
			</description>
			<field name="DataSource" type="xref" xref_entity="DataSource" nillable="false"/>
			<field name="Protocol" type="xref" xref_entity="Protocol" nillable="true" description="The protocol used to create this DataSet. All Features in this Protocol will be measured. Any Features in SubProtocols are already included in the list of the original protocol."/>
			<field name="StartTime" type="datetime" nillable="true" description="Time when the dataset was created." />
			<field name="EndTime" type="datetime" nillable="true" description="Time when the dataset was finished" />
			<field name="CreatedUsing" type="mref" xref_entity="DataSet" nillable="true" description="Other datasets that were involved in creating this one." />
		</entity>
		
		<entity name="DataItem" implements="AutoId" xref_label="Name">
			<description>
				DataItem is essentially a column in a dataset. It is a proxy for measuring a Feature. The reason Feature is not directly used as a 'column' is because Feature can be broader. For example, in a dataset of a large, homogeneous character such as genotypes, there could only be a single Feature ('Genotype', datatype = Marker) with many DataItems, each measuring the outcome of one specific Marker. The specific Marker is then referenced using the Scope field. (e.g. a Marker named 'rs723496') DataItems with the same Feature measure the same thing conceptually, only their scope differs.
			</description>
			<field name="Name" nillable="false " />
			<field name="DataSet" type="xref" xref_entity="DataSet" nillable="false" />
			<field name="Feature" type="xref" xref_entity="Feature" nillable="false" />
			<field name="Scope" type="xref" xref_entity="Target" nillable="true" />
			<unique fields="DataSet,Name" description="Must have a unique name within a DataSet" />
			<unique fields="DataSet,Feature,Scope" description="Either Feature is unique within a DataSet when there is no target, or the combination of Feature and Target is unique (within a DataSet)"/>
		</entity>
		
		<entity name="Observation" implements="AutoId">
			<description>
				A single row of values in a DataSet. The Methods of the ObservedValues referring to this ObservationSet should correspond to the Methods defined in the Protocol of the DataSet this ObservationSet belongs to.
			</description>
			<field name="DataSet" type="xref" xref_entity="DataSet"
				description="The DataSet this Observation is part of." />
			<field name="Time" type="datetime"
				description="The date and time this Observation was measured"
				nillable="true" />
			<unique fields="DataSet,Time" description="Only one Observation per timepoint can be made in a single DataSet" />
		</entity>
		
		<entity name="ObservedValue" implements="AutoId">
			<description>
				The value measured for the Observation (row) of a DataItem (column). The actual value is a reference to an instance of Value. There can be only one value per Observation/DataItem (row/column).
			</description>
			<field name="Value" type="xref" xref_entity="Value" nillable="false" />
			<field name="Observation" type="xref" xref_entity="Observation" nillable="false" />
			<field name="DataItem" type="xref" xref_entity="DataItem" nillable="false" />
			<unique fields="Observation,DataItem" description="There can be only one value per Observation/DataItem (row/column)" />
		</entity>

		<entity name="OntologyTerm" extends="Target">
			<description>
				An ontology term or other kind of alternative, often external identifier. Usually a link to other kind of database, or just a string denoting another possibility.
			</description>
			<field name="OntologySource" type="xref"
				xref_entity="OntologySource" />
		</entity>

		<entity name="OntologySource" extends="Target">
			<description>
				The location where this OntologyTerm links to or is originating from. The URL possibly needs a little mechanism to insert the alternative identifier into, e.g. URL "http://vega.sanger.ac.uk/Homo_sapiens/Gene/Summary?g={id};r=13:32889611-32973347" where {id} is replaced with an instance of OntologySource.Identifier "OTTHUMG00000017411" to form a valid URL.
			</description>
			<field name="Version" type="string" />
			<field name="urlPattern" type="string" description="Template for the url. E.g. 'http://www.pubmed.org/${Identifier}'"/>
			<unique fields="urlPattern,Version" description="The combination of url and version is unique"/>
		</entity>

	</module>
</molgenis>
